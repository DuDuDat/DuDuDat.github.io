---
layout: post
title: 텐서플로우와 케라스, 로스 함수와 딥러닝 기초 이론, 그리고 옵티마이저
img: 없엉
---

### 텐서플로우(TensorFlow)
@@ 텐서플로우는 머신러닝과 딥러닝을 위한 강력한 오픈소스 플랫폼으로, 복잡한 데이터 연산을 수행할 수 있는 도구를 제공합니다. 여기서 텐서란? 데이터를 다차원 배열로 표현한 것으로 텐서플로우에서 데이터 처리와 연산의 기본 단위 입니다.

### 케라스(Keras)
@@ 케라스는 텐서플로우의 API로 사용자가 보다 쉽게 딥러닝 모델을 구축하고 훈련할 수 있도록 설계되었습니다. 초기에 케라스는 텐서플로우 뿐만 아니라 Theano(테아노) 등 여러 백엔드 엔진 위에서 동작하는 독립적인 라이브러리 였지만 텐서플로우 2.0 이후 케라스가 텐서플로우의 공식 API로 통합되었고, 텐서플로우만의 백엔드를 사용하는 구조를 변모하였습니다.

++ 여기서 백엔드란? 웹 개발에서 사용하는 백엔드와는 다소 다른 개념입니다. 웹 개발에서의 백엔드는 서버, DB, 애플리케이션의 핵심 기능적 로직을 다루는 부분을 말하지만 여기서 백엔드 개념은 케라스가 연산과 데이터 처리를 위해 사용하는 수치 계산 라이브러리를 의미합니다.

### 신경망(Neural Networks)
@@ 신경망(Neural Networks) 또는 인공 신경망(Artificial Neural networks, ANN)은 인간 또는 동물의 뇌에서 영감을 얻은 컴퓨터 알고리즘으로, 데이터를 처리하고 학습하는 방법을 모방합니다. 이러한 네트워크는 뉴런이라고 불리는 기본적인 단위들로 구성되어 있으며, 이 뉴런들은 서로 복잡하게 연결되어 있습니다.

#### 신경망 구조
- 입력 레이어: 신경망의 첫 번째 단계로 외부 데이터를 받아들이는 역할을 합니다. 입력 노드는 각 입력 데이터 포인트의 특성을 나타냅니다.
- 은닉 레이어: 하나 이상 존재할 수 있으며, 데이터의 복잡한 패턴과 특징을 학습합니다.
- 출력 레이어: 신경망의 최종 예측 결과를 제공합니다.

++ 추가 정보


####

++ 오오 이렇게 되나

### 텐서플로우(TensorFlow)
> 머신러닝을 위한 오픈 플랫폼으로 딥러닝 프레임워크 중 하나이다.

#### 텐서(Tensor)
@@텐서플로우의 "텐서"는 데이터를 다차원 배열로 표현한 것으로 스칼라(0차원 텐서), 벡터(1차원 텐서), 행렬(2차원 텐서) 등이 있으며 이보다 많은 차원을 가진 배열도 텐서라고 부릅니다. 딥러닝에서는 이러한 텐서를 사용하여 데이터와 연산을 표현합니다.     
   
#### "Tensor Flow" 텐서가 흐른다 
@@ 텐서가 흐른다는 표현은 텐서플로우의 계산 방식을 설명하는데, 이는 데이터(텐서)가 노드(node)와 엣지(edge)로 구성된 그래프를 통해 흐른다는 것을 의미합니다. 여기서 노드는 수학적 연산을, 엣지는 노드 간에 텐서가 이동하는 경로를 나타냅니다. 즉, 텐서플로우는 데이터가 그래프 구조를 통해 연산되는 과정을 추상화하여 모델링하고 실행합니다.

#### 텐서 연산
@@ 텐서(다차원 배열)을 사용하여 수행하는 수학적 연산을 말합니다.

#### 텐서 연산의 종류
- 요소별 연산
- 행렬 곱셈
- 브로드캐스팅
- 차원 변환
- 축 기반 연산

> 구체적인 건 나중에....

### 케라스(Keras)
#### 케라스의 역할
@@ 케라스는 텐서플로우의 고수준 API로, 더 쉽고 편리하게 딥러닝 모델을 구축하고 훈련할 수 있게 해줍니다. 케라스를 사용하면 복잡한 텐서플로우의 세부 구현을 신경 쓰지 않고, 간결한 코드로 모델 구조를 정의하고 학습을 진행할 수 있습니다. 예를 들어 몇 줄의 코드만으로 신경망을 구성하고 훈련할 수 있습니다.

#### 케라스와 텐서플로우의 관계
@@ 초기에 케라스는 텐서플로우, 테아노(Theano), CNTK 등 여러 백엔드 엔진 위에서 동작하는 독립적인 라이브러리였습니다. 하지만 텐서플로우 2.0 이후 케라스가 텐서플로우의 공식 API로 통합되었고, 텐서플로우만의 백엔드를 사용하는 구조로 변모하였습니다. 이 통합으로 사용자는 텐서플로우의 강력한 기능과 케라스의 사용 편의성을 함께 활용할 수 있게 되었습니다.

#### 케라스에서 말하는 백엔드
@@ 케라스에서 말하는 백엔드는 웹 개발에서 사용하는 백엔드와는 다소 다른 개념입니다. 웹 개발에서의 백엔드는 서버, 데이터베이스, 애플리케이션의 핵심 기능적 로직을 다루는 부분을 말하지만, 케라스의 백엔드는 수치 계산과 텐서 연산을 처리하는 라이브러리를 지칭합니다.

#### 케라스 모델 정의
@@ 케라스 에서 모델을 정의할 때 입력과 출력의 크기를 설정합니다. 이 설정은 내부적으로 네트워크의 가중치와 바이어스를 초기화하는데 사용됩니다.

> 구체적인 건 나중에...

### 신경망(Neural Networks)
> 신경망(Neural Networks) 또는 인공 신경망(Artificail Neural networks, ANN)은 인간 또는 동물의 뇌에서 영감을 얻은 컴퓨터 알고리즘으로, 데이터를 처리하고 학습하는 방법을 모방합니다. 이러한 네트워크는 뉴런이라고 불리는 기본적인 단위들로 구성되어 있으며, 이 뉴런들은 서로 복잡하게 연결되어 있습니다.

#### 신경망 구조 
##### 입력 레이어(Input Layer)
- 신경망의 시작점으로 외부 데이터를 네트워크로 받아들이는 역할을 합니다.
- 모든 입력 특성(예: 이미지의 픽셀 값, 데이터셋의 변수 값 등)이 이 레이어의 노드(입력노드)에 해당합니다.

##### 은닉 레이어(Hidden Layer)
- 입력 레이어와 출력 레이어 사이에 위치한 하나 이상의 레이어로 구성됩니다.
- 이 레이어들은 신경망의 핵심 부분으로 데이터에서 복잡한 특징과 패턴을 학습합니다.
- 은닉 레이어는 사용자에게 보이지 않으며 내부 처리를 담당합니다.

##### 출력 레이어(Output Layer)
- 신경망의 마지막 레이어로 최종 예측이나 분류 결과를 제공합니다.
- 예를 들어 분류 문제에서는 각 클래스에 해당하는 출력 노드가 있으며, 각 노드는 특정 클래스에 속할 활률을 출력합니다.

@@ 레이어란? 신경망에서 노드(또는 뉴런)들이 모여 있는 층을 의미합니다. 각 레이어는 특정 기능을 수행하며, 노드들은 동일한 레이어 내에서 입력을 받아 처리한 후 결과를 다음 레이어로 전달합니다. 신경망의 각 레이어는 하나의 처리 단계를 나타내며, 신경망의 전체적인 구조와 성능에 중요한 역할을 합니다.

@@ 딥 러닝이라는 용어는 흔히 신경망이 많은 은닉 레이어를 포함할 때 사용됩니다. 일반적인 인공 신경망과 비교할 때 딥 러닝 모델은 더 깊은 구조를 가지고 있으며 이로 인해 더 복잡하고 추상적인 패턴을 데이터에서 학습할 수 있습니다.

### 딥 러닝에 대한 간략한 설명
#### 딥 러닝 모델을 구축할 때 핵심적인 구성요소
##### 손실 함수(Loss Function)와 비용 함수(Cost Function)
@@ 손실 함수 또는 비용 함수는 모델의 예측이 실제 값과 얼마나 잘 맞는지를 수치적으로 평가하는 함수입니다. 이 함수의 값(즉, 손실 또는 비용)을 최소화하는 것이 학습의 목표입니다. 손실 함수는 주로 다음과 같은 유형으로 나뉩니다.
- 평균 제곱 오차(Mean Squared Error, MSE): 회귀 문제에서 주로 사용되며, 예측 값과 실제 값 간의 차이의 제곱을 평균낸 것입니다.
- 크로스 엔트로피 손실(Cross-Entropy Loss): 분류 문제에서 사용되며, 실제 클래스와 예측된 클래스 확률 분포 간의 차이를 측정합니다. 이는 클래스가 잘못 분류될 때 큰 패널티를 부과합니다.

@@ 딥러닝에서는 각 학습 단계에서 손실 함수의 값을 계산하고 이 값을 최소화하기 위해 옵티마이저를 사용하여 가중치를 조정합니다. 학습이 끝난 후에도 모델이 새로운 데이터에 대해 얼마나 잘 작동하는지를 평가하기 위해 손실 함수나 다른 성능 지표를 사용할 수 있습니다. 이는 모델의 성능을 객관적으로 평가하는 데 도움을 줍니다.

##### 옵티마이저(Optimizer)
@@ 옵티마이저는 모델의 가중치를 조정하는 방법을 정의하며, 손실 함수의 값을 최소화하기 위해 사용됩니다. 옵티마이저는 학습 과정에서 모델의 가중치를 어떻게 업데이트할지 결정합니다. 다음은 몇 가지 주요 옵티마이저입니다.
- SGD (Stochastic Gradient Descent): 가장 기본적인 옵티마이저로, 각 반복에서 무작위로 선택된 데이터 샘플에 대해 가중치를 업데이트합니다.
- Momentum: SGD의 변형으로, 이전 업데이트를 고려하여 가중치를 조정함으로써 학습 과정을 안정화하고 가속화합니다.
- Adam(Adaptive moment Estimation): Momentum과 RMSprop의 아이디어를 결합하여 각 가중치에 대해 개별적인 학습률을 조정합니다. 이는 매우 인기 있는 옵티마이저로 널리 사용됩니다.

@@ 옵티마이저는 손실 함수의 결과에 따라 모델의 가중치를 어떻게 조정할지를 결정합니다. 이는 손실 함수의 기울기(Gradient)를 계산하여 이를 사용해 가중치를 업데이트함으로써 손실을 줄이는 방향으로 작업합니다.

> 딥러닝 레이어 구조 이미지는 하용호님 자료가 굉장히 유명하다는모양


### 신경망의 기본 구조
#### 입력 레이어 : 각 노드는 학습 데이터의 한 특성(컬럼)을 나타냅니다. 예를 들어 x가 입력 노드이며, y는 출력(목표 변수)입니다.
#### 은닉 레이어 : 입력 레이어와 출력 레이어 사이의 레이어로 복잡한 패턴을 학습합니다. 각 노드는 입력 레이어의 출력에 가중치를 적용받고 활성화 함수를 통과하여 결과를 출력합니다. 여기서 활성화 함수는 뭐지?
#### 출력 레이어: 최종적인 예측 결과를 나타내는 레이어입니다. 회귀 문제에서는 보통 하나의 노드만 포함합니다.


### 선형 회귀 모델과 딥러닝
#### 선형 회귀 모델 $$y = xW + b$$ 형태의 모델로 x는 입력 변수 W는 가중치 b는 편향(절편)입니다. 이는 가장 기본적인 신경망 형태로 볼 수 있으며, 여기서 W와 b를 찾는 것이 목표입니다.
#### 손실 함수와 옵티마이저
- 손실 함수(Loss Function): 모델의 예측이 실제 값과 얼마나 차이가 있는지를 측정합니다. MSE(Mean Squared Error)는 회귀 문제에서 자주 사용됩니다.
- 옵티마이저(Optimizer): 손실 함수를 최소화하기 위해 모델의 가중치를 조정하는 메커니즘입니다. 예를 들어 RMSprop, Adam 등이 있습니다.
### 모델의 컴파일과 학습
- Model.compile() : 모델을 학습하기 전에 손실 함수와 옵티마이저를 설정합니다.
- Model.fit() : 실제로 모델에 데이터를 넣고 학습을 진행합니다. 이 과정에서 데이터는 여러 번 (epoch) 모델을 통과하며 각 epoch마다 손실이 감소해야 합니다. 모델을 학습시킬 때, epoch는 전체 데이터셋을 한 번 모델에 통과시키는 것을 의미하고 epochs는 그걸 반복한 횟수라고 말할 수 잇는듯?

### 모델 평가와 예측
- model.evaluate(): 학습된 모델을 테스트 데이터로 평가하여 성능을 측정합니다.
- model.predict(): 새로운 데이터에 대해 예측을 수행합니다.

### 모델의 가중치 접근
- model.get_weight(): 학습된 모델의 가중치와 편향을 추출할 수 있습니다. 이 정보는 모델이 어떻게 데이터를 해석하는지 이해하는데 유용합니다.

#### 선형 회귀 모델
- 선형 회귀는 가장 간단한 형태의 신경망이라고 설명할 수 있으며, 이는 입력 x와 출력 y 간의 선형 관계를 모델링합니다. 하지만 이것을 신경망의 일종으로 설명할 때는 단층 퍼셉트론 (Single-layer Perceptron)이라는 용어를 사용할 수 있습니다.

### keras에서 hist 객체
@@ hist 객체란? keras에서 모델을 학습시킬 때 model.fit()함수를 호출하면 자동으로 History 객체를 반환합니다. 이 객체는 hist라는 변수에 저장하고 학습 과정에서의 여러 통계치를 확인할 수 있습니다. History 객체는 history라는 속성을 가지고 있습니다. 이 속성은 dict 형태로 학습 동안의 손실 값과 설정된 경우 다른 메트릭 값들을 에포크 별로 저장합니다. 여기서 history['loss']는 각 에포크 마다 계산된 손실 값을 리스트 형태로 포함하고 있습니다.

### 차원의 중요성
- 행렬의 차원과 reshape 신경망에서 데이터를 처리할 때 차원의 일관성은 중요합니다. 예를 들어 y의 예상출력이 (25, 1) 형태이지만 실제로는 (25, )로 나올 경우 이는 차원이 맞지 않아 다른 연산에서 문제가 발생할 수 있습니다. 예측 결과를 다른 행렬과의 연산에 사용할 때 차원이 일치해야만 오류 없이 연산이 수행됩니다.예측 결과의 차원을 명확히 (25, 1)로 만들기 위해 reshape 함수를 사용할 수 있습니다. 이는 데이터의 전체 개수를 변경하지 않고 형태만을 바꿔 다른 연산이나 함수의 입력으로 적절히 사용될 수 있게 합니다.

#### 바이어스란?
- 모델의 각 뉴런에서 계산되는 추가적인 입력값으로 모델의 출력을 조절하는 데 도움을 주는 값입니다. 이는 레이블과는 별개로 레이블은 모델의 학습 과정에서 사용되는 실제 결과 값으로 모델이 예측해야 할 값입니다.


## 전체 정리본은 아래에 두자 하지만 진짜 전체 정리인지는 글쎄...?

텐서플로우(TensorFlow)와 텐서
텐서플로우는 머신러닝과 딥러닝을 위한 강력한 오픈소스 플랫폼으로, 복잡한 데이터 연산을 수행할 수 있는 도구를 제공합니다.
텐서는 데이터를 다차원 배열로 표현한 것으로, 텐서플로우에서 데이터 처리와 연산의 기본 단위입니다.
케라스(Keras)
케라스는 텐서플로우의 고수준 API로서, 사용자가 보다 쉽게 딥러닝 모델을 구축하고 훈련할 수 있도록 설계되었습니다.
백엔드는 케라스가 연산과 데이터 처리를 위해 사용하는 수치 계산 라이브러리를 의미합니다. 웹 개발의 백엔드와는 다른 의미로, 케라스의 계산 처리 역할을 수행합니다.
신경망 구조
입력 레이어: 외부 데이터를 받아들이는 신경망의 첫 번째 단계로, 각 입력 데이터 포인트의 특성을 나타냅니다.
은닉 레이어: 하나 이상 존재할 수 있으며, 데이터의 복잡한 패턴과 특징을 학습합니다.
출력 레이어: 신경망의 최종 예측 결과를 제공합니다.
딥 러닝
딥 러닝은 많은 은닉 레이어를 포함하는 신경망을 의미하며, 이를 통해 더 복잡하고 추상적인 데이터 패턴을 학습할 수 있습니다.
학습 과정
손실 함수(Loss Function): 모델이 학습하는 동안 예측의 정확성을 측정하는 데 사용됩니다.
옵티마이저(Optimizer): 손실 함수의 결과에 따라 모델의 가중치를 조정하는 방법을 정의합니다. 이는 모델의 학습 과정을 최적화하는 데 필수적입니다.
모델 평가와 예측
**model.evaluate()**는 테스트 데이터셋을 사용하여 모델의 성능을 평가합니다.
**model.predict()**는 새로운 데이터에 대한 예측을 수행합니다.
바이어스와 레이블의 차이
바이어스는 모델이 학습할 때 사용하는 파라미터 중 하나로, 출력을 조정하는 데 도움을 줍니다.
레이블은 학습 데이터의 각 샘플에 대한 실제 결과값으로, 모델이 예측을 수행할 때 참조하는 목표값입니다.